package main

import "fmt"

// 1. создаём второй массив(стэк), куда складываем все открывающие скобки
// 2. пробегаемся по исходному массиву циклом, смотрим тип скобок, открытые или закрытые
// 3. соответствующие закрывающие удаляем, при встрече не соответствующих возвращаем false
func isValid(s string) bool {
	sli := []rune(s)                    // переводим строку в срез рун
	nSli := make([]rune, 0, len(sli)/2) // создаём срез-стэк
	// исключаем затраты ресурсов на работу с кейсами с нечетным количеством элементов
	if len(sli)%2 != 0 {
		fmt.Printf("Один лишний элемент в строке: ")
		return false
	}
	// пробегаемся по входному срезу рун
	for i := 0; i < len(sli); i++ {
		// все открывающие скобки записываем в срез-стэк
		if sli[i] == '[' || sli[i] == '{' || sli[i] == '(' {
			nSli = append(nSli, sli[i])
			continue // завершаем итерацию цикла
		}
		// по всем остальным видам скобок (нет смысла их перечислять) пробегаемся свичом
		switch {
		case len(nSli) == 0: // исключающий панику кес с пустым стеком(либо не добавили ещё, либо уже удалили)
			fmt.Printf("В стэке нет скобок: ")
			return false
		// согласно таблице UTF-8
		// закрывающая круглая скобка отличается от открывающей на -1(в отличие от фигурной и квадратной)
		// поэтому этот кейс берем отдельно и на -2 у остальных типов скобок
		case sli[i] == ')' && ')'-1 == nSli[len(nSli)-1] || sli[i]-2 == nSli[len(nSli)-1]:
			nSli = nSli[:len(nSli)-1] // удаляем совпавшую скобку
		// если предыдущее условие не сработало, значит скобки не совпадают, возвращаем false
		default:
			fmt.Printf("Скобки не совпали: ")
			return false
		}
	}
	// исключаем кейс когда в срезе-стэке всё-ещё остались незакрытые скобки, а в основном все скобки закончились
	if len(nSli) != 0 {
		fmt.Printf("Не все скобки были закрыты: ")
		return false
	}
	// победа, цикл завершен
	return true
}

// альтернативное решение

//func isValid(s string) bool {
//	pairs := map[byte]byte{ // создаётся мапа, где ключ закрывающая скобка, а значение открывающая
//		'}': '{',
//		']': '[',
//		')': '(',
//	}
//
//	stack := make([]byte, 0)
//
//	for _, char := range []byte(s) {
//		pair, ok := pairs[char]
//		if !ok {
//			stack = append(stack, char)
//			continue
//		}
//
//		if len(stack) == 0 {
//			return false
//		}
//
//		if stack[len(stack) - 1] != pair {
//			return false
//		}
//
//		stack = stack[:len(stack) - 1]
//	}
//
//	return len(stack) == 0
//}
